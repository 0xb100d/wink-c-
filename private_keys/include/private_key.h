#ifndef PRIVATE_KEY_INCLUDED
#define PRIVATE_KEY_INCLUDED

#include "../core/ecc_native.h"
#include "../core/ecc.h"
#include <string.h>
#include <vector>
#include <iostream>


// Pseudonyms for usefull work
using ScalarValue = ECC::Scalar::Native;
using Scalar      = ECC::Scalar;
using Point       = ECC::Point;
using PointValue  = ECC::Point::Native;
using PointGen    = ECC::Context;
using KeyPhrase   = const char*; // it's created by user

const ScalarValue ONE = 1U;

// Random generator is used to initiate starting state of Nonce
unsigned int get_random();


// Nonce is used to create private key assortiment with varying key values:
// Here the formula is used:
//
// PrivateKeyPoint[i] = (PrivateKeyScalar + Nonce[i]) * G,
//
// where G     - point-generator of elliptic urve and
//       Nonce - some generator of scalar with specific rule of scalar generating
//       i     = 0...(count of keys) - 1
struct Nonce {

    ScalarValue init_state;
    size_t      counter;

    Nonce() : counter(0) {
        init_state = get_random();
    }

    Nonce(unsigned int init_state_) {
        init_state = init_state_;
    }

    ScalarValue get();
    ScalarValue get_init_state();
    void reset();
};


// Scalar of private key is just scalar. It's generated by any user's phrase
struct PrivateKeyScalar {

    Scalar key;

    PrivateKeyScalar() = default;

    PrivateKeyScalar(Scalar val) : key(val) {}

    PrivateKeyScalar(KeyPhrase phrase) {

        // scalar of private key = convert2scalar(sha256(any user's phrase))

        ECC::Hash::Processor hash_processor;
        ECC::Hash::Value hash_value;

        hash_processor.Write(phrase, strlen(phrase));

        hash_processor >> hash_value;

        key.m_Value = hash_value;
    }

    PrivateKeyScalar& operator += (Nonce& nonce);

    ScalarValue getNative() const;

};


// Point of private key is multiplication of scalar of private key
// and point-generator of elliptic curve,
// it's just a point of elliptic curve
struct PrivateKeyPoint {

    Point value;

    PrivateKeyPoint(PointGen& gen,
                    const PrivateKeyScalar scalar,
                    Nonce& nonce)
    {
        ScalarValue sn = scalar.getNative();
        sn += nonce.get();

        PointValue pG = gen.get().G * sn; ;
        value = pG;
    }

    // Compare two PrivateKeyPoint
    int cmp(const PrivateKeyPoint& other) const;

    // Create a set of private keys,
    // which are points on curve are generated by some point-generator
    // and some Nonce for some scalar of private key
    static std::vector<PrivateKeyPoint> create_keyset(PointGen& gen,
                                                      const PrivateKeyScalar scalar,
                                                      Nonce& nonce,
                                                      size_t count_key);

};


// Generator of private keys (i.e. generator of points on elliptic curve)
struct KeyGenerator {

    PointGen         point_gen;
    KeyPhrase        phrase;
    Nonce            nonce;
    PrivateKeyScalar scalar;

    KeyGenerator() = default;

    KeyGenerator(PointGen  gen_,
                 KeyPhrase phrase_) : point_gen(gen_),
                                      phrase(phrase_),
                                      scalar(phrase_)  {}

    KeyGenerator(KeyPhrase phrase_) : phrase(phrase_),
                                      scalar(phrase_)  {}

    // Generate next key
    PrivateKeyPoint next();

    void reset();
    void write(std::ofstream &os);

    static KeyGenerator recover(std::ifstream &is);
};

constexpr size_t SIZKEYGEN = sizeof(KeyGenerator);

#endif // PRIVATE_KEY_INCLUDED
