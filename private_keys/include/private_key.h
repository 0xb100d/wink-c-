#ifndef PRIVATE_KEY_INCLUDED
#define PRIVATE_KEY_INCLUDED

#include <string.h>
#include <vector>
#include <iostream>
#include <chrono>
#include <random>
#include <limits>

#include "../core/ecc_native.h"
#include "../core/ecc.h"
#include "utill.h"

// Pseudonyms for usefull work
using ScalarValue = ECC::Scalar::Native;
using Scalar      = ECC::Scalar;
using Point       = ECC::Point;
using PointValue  = ECC::Point::Native;
using PointGen    = ECC::Context;
using KeyPhrase   = const char*; // it's created by user

bool operator==(const Scalar& left, const Scalar& rigth);

const ScalarValue ONE = 1U;

// Random generator is used to initiate starting state of Nonce
unsigned int get_random();


// Nonce is used to create private key assortiment with varying key values:
// Here the formula is used:
//
// PrivateKeyPoint[i] = (PrivateKeyScalar + Nonce[i]) * G,
// PrivateKey[i]      = PrivateKeyPoint[i].X
//
// where G     - point-generator of elliptic curve and
//       Nonce - some generator of scalar with specific rule of scalar generating
//       i     = 0...(count of keys) - 1
struct Nonce {

    Nonce() : counter(0) {
        init_state = get_random();
    }

    Nonce(unsigned int state_) : init_state(state_) {}

    Nonce& operator=(const Nonce& other) = default;

    ScalarValue get();
    ScalarValue get_init_state();

    // Set counter of Nonce to zero
    void reset();

    private:
        ScalarValue init_state;
        size_t      counter;
};

// Scalar of private key is just scalar. It's generated by any user's phrase
struct PrivateKeyScalar {

    PrivateKeyScalar() = default;
    PrivateKeyScalar(Scalar val) : key(val) {}

    PrivateKeyScalar(KeyPhrase phrase) {

        // scalar of private key = convert2scalar(sha256(any user's phrase))

        ECC::Hash::Processor hash_processor;
        ECC::Hash::Value hash_value;

        hash_processor.Write(phrase, strlen(phrase));

        hash_processor >> hash_value;

        key.m_Value = hash_value;
    }

    PrivateKeyScalar& operator=(const PrivateKeyScalar& other) = default;

    PrivateKeyScalar& operator+=(Nonce& nonce);

    ScalarValue getNative() const;

    Scalar get() const;

    private:
        Scalar key;
};

// It's just scalar =
// = coordinate X of some point of elliptic curve =
// = multiplication of scalar of private key and
//   point-generator of elliptic curve
struct PrivateKey {

    PrivateKey() = default;

    PrivateKey(PointGen& gen,
               const PrivateKeyScalar scalar,
               Nonce& nonce)
    {
        ScalarValue sn = scalar.getNative();
        sn += nonce.get();

        PointValue pG = gen.get().G * sn; ;
        Point point = pG;

        key.m_Value = point.m_X;
    }

    PrivateKey& operator=(const PrivateKey& other) = default;

    Scalar get();

    // Compare two PrivateKey
    bool cmp(const PrivateKey& other) const;

    // Create a vector of private keys
    static std::vector<PrivateKey> create_keyset(PointGen& gen,
                                                 const PrivateKeyScalar scalar,
                                                 Nonce& nonce,
                                                 size_t count_key);
    private:
        Scalar key;

};

// Generator of private keys
struct KeyGenerator {

    KeyGenerator() = default;

    KeyGenerator(PointGen  gen_,
                 KeyPhrase phrase_) : point_gen(gen_),
                                      phrase(phrase_),
                                      scalar(phrase_),
                                      count_key(0)  {}

    KeyGenerator(KeyPhrase phrase_) : phrase(phrase_),
                                      scalar(phrase_),
                                      count_key(0)  {}

    KeyGenerator& operator=(const KeyGenerator& other) {

        scalar = other.scalar;
        phrase = other.phrase;
        nonce  = other.nonce;

        return *this;
    }

    size_t get_count();

    // Generate next key
    PrivateKey next();

    // Set counter of Nonce to zero
    void reset();

    void write(std::ofstream &os);
    void write(std::ofstream &os, const char* key);

    static KeyGenerator* recover(std::ifstream &is);
    static KeyGenerator* recover(std::ifstream &is, const char* key);

    private:
        size_t           count_key;
        PointGen         point_gen;
        KeyPhrase        phrase;
        Nonce            nonce;
        PrivateKeyScalar scalar;
};

constexpr size_t SIZKEYGEN = sizeof(KeyGenerator);

#endif // PRIVATE_KEY_INCLUDED
